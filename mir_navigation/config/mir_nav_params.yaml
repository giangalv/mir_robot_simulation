amcl:
# It helps the robot understand its location on a map. 
# It uses a particle filter to estimate the robot’s position by matching laser scans from a LIDAR sensor with the existing map. 
  ros__parameters:
    use_sim_time: False
    alpha1: 0.2 # Noise in odometry's rotation estimate from rotation
    alpha2: 0.2 # Noise in odometry's rotation estimate from translation
    alpha3: 0.2 # Noise in odometry's translation estimate from translation
    alpha4: 0.2 # Noise in odometry's translation estimate from rotation
    alpha5: 0.2 # Noise for translation in omni-directional motion
    base_frame_id: "base_footprint"
    beam_skip_distance: 0.5 # Maximum distance to consider skipping beams that don't match the map
    beam_skip_error_threshold: 0.9 # Percentage of beams to skip before forcing a full update due to bad convergence
    beam_skip_threshold: 0.3 # Percentage of beams required to skip
    do_beamskip: false # Percentage of beams required to skip before forcing a full update
    global_frame_id: "map"
    lambda_short: 0.1 
    laser_likelihood_max_dist: 2.0
    laser_max_range: 50.0 # 100.0 in meters
    laser_min_range: -1.0 # 0.1 
    laser_model_type: "likelihood_field" # "beam" or "likelihood_field_pro"
    max_beams: 60 # Number of evenly spaced beams to use from each scan
    max_particles: 2000 # Maximum number of particles to use in the filter
    min_particles: 500 # Minimum number of particles to use in the filter
    odom_frame_id: "odom"
    pf_err: 0.05
    pf_z: 0.99
    recovery_alpha_fast: 0.0
    recovery_alpha_slow: 0.0
    resample_interval: 1
    robot_model_type: "nav2_amcl::DifferentialMotionModel"
    save_pose_rate: 0.5
    sigma_hit: 0.2
    tf_broadcast: True
    transform_tolerance: 1.0 #2.0
    update_min_a: 0.1 # Minimum angle to consider a new pose, decreasing this value makes the robot update more often
    update_min_d: 0.15 # Minimum distance to consider a new pose, decreasing this value makes the robot update more often
    z_hit: 0.5 # Percentage of trusting the sensor readingd that match the map perfectly
    z_max: 0.05 # How much to trust maximum range readings, when the sensor doesn't see anything in range
    z_rand: 0.5 # How much to expect random, unexplainable sensor readings. Decrasing it assumes sensor readings should mostly mathc the map
    z_short: 0.05 
    scan_topic: /mir_scan
    #set_initial_pose: false
    #always_reset_initial_pose: false
    #first_map_only: false
    #service_introspection_mode: "disabled"
    #initial_pose:
    #  x: 0.0
    #  y: 0.0
    #  z: 0.0
    #  yaw: 0.0

bt_navigator:
# It acts as the central decision maker, coordinating the robot's navigation tasks throught behavior trees.
  ros__parameters:
    use_sim_time: False
    global_frame: map
    robot_base_frame: base_link
    odom_topic: /odom
    bt_loop_duration: 10 # How oftren the robot's "brain" makes decsions in ms (it makes 100 decisions per second)
    default_server_timeout: 20 # How long to wait for navigation components to respond  in ms
    wait_for_service_timeout: 1000 # Timeout for BT nodes waiting for acknowledgement from a service or action server during initialization
    action_server_result_timeout: 900.0 # Timeout for action servers to discard a goal handle if a result hasn't benn produced in seconds (15 minutes)
    # Navigators are set up in the navigation.py file, and the default ones are:
    # -> navigate_to_pose_w_replanning_and_recovery.xml
    # nav2_bt_navigator/navigate_through_poses_w_replanning_and_recovery.xml
    # Note: Not quite correct, params that are not mentioned can not be substituted!
    plugin_lib_names:
    - nav2_compute_path_to_pose_action_bt_node
    - nav2_compute_path_through_poses_action_bt_node
    - nav2_smooth_path_action_bt_node
    - nav2_follow_path_action_bt_node
    - nav2_spin_action_bt_node
    - nav2_wait_action_bt_node
    - nav2_assisted_teleop_action_bt_node
    - nav2_back_up_action_bt_node
    - nav2_drive_on_heading_bt_node
    - nav2_clear_costmap_service_bt_node
    - nav2_is_stuck_condition_bt_node
    - nav2_goal_reached_condition_bt_node
    - nav2_goal_updated_condition_bt_node
    - nav2_globally_updated_goal_condition_bt_node
    - nav2_is_path_valid_condition_bt_node
    - nav2_initial_pose_received_condition_bt_node
    - nav2_reinitialize_global_localization_service_bt_node
    - nav2_rate_controller_bt_node
    - nav2_distance_controller_bt_node
    - nav2_speed_controller_bt_node
    - nav2_truncate_path_action_bt_node
    - nav2_truncate_path_local_action_bt_node
    - nav2_goal_updater_node_bt_node
    - nav2_recovery_node_bt_node
    - nav2_pipeline_sequence_bt_node
    - nav2_round_robin_node_bt_node
    - nav2_transform_available_condition_bt_node
    - nav2_time_expired_condition_bt_node
    - nav2_path_expiring_timer_condition
    - nav2_distance_traveled_condition_bt_node
    - nav2_single_trigger_bt_node
    - nav2_goal_updated_controller_bt_node
    - nav2_is_battery_low_condition_bt_node
    - nav2_navigate_through_poses_action_bt_node
    - nav2_navigate_to_pose_action_bt_node
    - nav2_remove_passed_goals_action_bt_node
    - nav2_planner_selector_bt_node
    - nav2_controller_selector_bt_node
    - nav2_goal_checker_selector_bt_node
    - nav2_controller_cancel_bt_node
    - nav2_path_longer_on_approach_bt_node
    - nav2_wait_cancel_bt_node
    - nav2_spin_cancel_bt_node
    - nav2_back_up_cancel_bt_node
    - nav2_assisted_teleop_cancel_bt_node
    - nav2_drive_on_heading_cancel_bt_node
  error_code_names: [“compute_path_error_code”, “follow_path_error_code”]
  transform_tolerance: 0.1

bt_navigator_navigate_through_poses_rclcpp_node:
  ros__parameters:
    use_sim_time: False

bt_navigator_navigate_to_pose_rclcpp_node:
  ros__parameters:
    use_sim_time: False

controller_server:
# It ensures the robot follows the path correctly, avoids obstacles using the local map around it, uses various plugins to check its progress and confirm when the robot reaches its goal.
  ros__parameters:
    use_sim_time: False
    controller_frequency: 20.0
    costmap_update_timeout: 0.30 # How long to wait for the costmap to update before giving up in seconds
    min_x_velocity_threshold: 0.001 # Minimum velocity threshold to filter odometry noise in the x direction
    min_y_velocity_threshold: 0.5 # Minimum velocity threshold to filter odometry noise in the y direction
    min_theta_velocity_threshold: 0.001 # Minimum angular velocity threshold to filter odometry noise
    failure_tolerance: 0.1 # Allowing the controller to fail for up to 0.1 seconds before the FolowPath action fails provides some tolerance for temporary failures
    
    progress_checker_plugin: "progress_checker" # Monitoring the robot's progress
    progress_checker:
      plugin: "nav2_controller::SimpleProgressChecker"
      required_movement_radius: 0.5 # In meters, it is a threshold for determining if the robot has made sufficient progress
      movement_time_allowance: 10.0 # In seconds, time limit before considering the robot to be stuck
    
    goal_checker_plugins: ["general_goal_checker"] # "precise_goal_checker"
    general_goal_checker:
      #stateful: True
      plugin: "nav2_controller::SimpleGoalChecker"
      xy_goal_tolerance: 0.25 # In meters, the distance from the goal position to consider it reached
      yaw_goal_tolerance: 0.25 # In radians, the angle from the goal orientation to consider it reached
    #precise_goal_checker:
    #  plugin: "nav2_controller::SimpleGoalChecker"
    #  xy_goal_tolerance: 0.25
    #  yaw_goal_tolerance: 0.25
    #  stateful: True

    controller_plugins: ["FollowPath"]
    FollowPath:
      plugin: "nav2_mppi_controller::MPPIController"
      time_steps: 56 # Each time step represents a future point where trajectories are evaluated
      model_dt: 0.05 # Time step for the model, in seconds 
      batch_size: 3000 # Number of trajectories to sample for each time step
      vx_std: 0.2 # Standard deviation for the x velocity m/s
      vy_std: 0.2 # Standard deviation for the y velocity m/s
      wz_std: 0.4 # Standard deviation for the angular velocity rad/s
      vx_max: 0.5 # Maximum x velocity m/s
      vx_min: -0.35 # Minimum x velocity m/s
      vy_max: 0.5 # Maximum y velocity m/s
      wz_max: 1.9 # Maximum angular velocity rad/s
      ax_max: 1.5 # Maximum x acceleration m/s^2
      ax_min: -1.5 # Minimum x acceleration m/s^2
      ay_max: 1.5 # Maximum y acceleration m/s^2
      az_max: 2.0 # Maximum angular acceleration rad/s^2
      iteration_count: 1 # Iteration count for the MPPI algorithm
      #prune_distance: 1.7 (default 1.5)
      #transform_tolerance: 0.1 (default 0.1)

      ### for debugging  ###
      #visualize: false (default false) only for debugging
      #TrajectoryVisualizer:
      #  trajectory_step: 5
      #  time_step: 3
      #AckermannConstraints:
      #  min_turning_r: 0.2
      ## for debugging  ###

      temperature: 0.3 # Controls how strongly the controller favors lower-cost trajectories
      gamma: 0.015 # Controls how the controller weighs trajectory costs in its decision-making
      motion_model: "DiffDrive"

      critics: ["ConstraintCritic", "CostCritic", "GoalCritic", "GoalAngleCritic", "PathAlignCritic", "PathFollowCritic", "PathAngleCritic", "PreferForwardCritic"]
      # Robot limits
      ConstraintCritic: # Make sure the robot follows the constraints of the motion model
        enabled: true
        cost_power: 1
        cost_weight: 4.0
      # Obstacle avoidance
      CostCritic: # Think of this like a bubble around the robot to keep it safe
          enabled: true
          cost_power: 1
          cost_weight: 3.81
          critical_cost: 300.0
          consider_footprint: true
          collision_cost: 1000000.0
          near_goal_distance: 1.0
          trajectory_point_step: 2
      # Getting to destination
      GoalCritic: # This is the cost of the robot being far from the goal position
              enabled: true
              cost_power: 1
              cost_weight: 5.0 # Determines how much the robot reaches the exact spot
              threshold_to_consider: 1.4 # In meters, it is the distance where the robot starts to focus on the goal
      # Final rotation
      GoalAngleCritic: # This is the cost of the robot being far from the goal angle
          enabled: true
          cost_power: 1
          cost_weight: 3.0 # Determines how much the robot reaches the exact angle
          threshold_to_consider: 0.5 # In meters, it is the distance where the robot starts to focus on the final angle
      # Staying on path
      PathAlignCritic:
            enabled: true
            cost_power: 1
            cost_weight: 14.0 # Determines how much the robot aligns with the path
            #max_path_occupancy_ratio: 0.05
            #trajectory_point_step: 4
            threshold_to_consider: 0.5 # In meters, it stops the robot to follow the path when it's very close to the goal
            #offset_from_furthest: 20
            #use_path_orientations: false
      # Path direction
      PathAngleCritic:
          enabled: true
          cost_power: 1
          cost_weight: 2.0
          #offset_from_furthest: 4
          threshold_to_consider: 0.5 # In meters, it stops the robot caring about path direction and focuses on final position
          #max_angle_to_furthest: 1.0
          #forward_preference: true
      # Forward progress
      PathFollowCritic:
            enabled: true
            cost_power: 1
            cost_weight: 5.0 # Determines how strongly the robot is urged to move forward
            #offset_from_furthest: 5
            threshold_to_consider: 1.4 # In meters, it stops the robot caring about path direction and focuses on final position
      # Forward motion
      PreferForwardCritic:
        enabled: true
        cost_power: 1
        cost_weight: 5.0 # Determines how much the robot prefers to move forward
        threshold_to_consider: 0.5 # In meters, it stops the robot caring about 
          
      # Smooth rotation for omni-directional robots
      #TwirlingCritic:
      #  enabled: true
      #  cost_power: 1
      #  cost_weight: 10.0 # Determines how much the robot prefers to rotate smoothly

      # Option to replace Cost and use Obstacles instead
      # ObstaclesCritic:
      #   enabled: true
      #   cost_power: 1
      #   repulsion_weight: 1.5
      #   critical_weight: 20.0
      #   consider_footprint: false
      #   collision_cost: 10000.0
      #   collision_margin_distance: 0.1
      #   near_goal_distance: 0.5

      # VelocityDeadbandCritic:
      #   enabled: true
      #   cost_power: 1
      #   cost_weight: 35.0
      #   deadband_velocities: [0.05, 0.05, 0.05]
      

local_costmap:
  local_costmap:
    ros__parameters:
      use_sim_time: False
      #transform_tolerance: 0.5 # 0.2
      update_frequency: 5.0
      publish_frequency: 5.0 # 2.0
      global_frame: odom
      robot_base_frame: base_link
      rolling_window: True # Allows the costmap to move with the robot
      width: 5 # In meters
      height: 5 # In meters
      resolution: 0.05
      # offset: front / back from base_link
      # footprint: '[ [front, width/2], [back, width/2], [-back, -width/2], [front, -width/2] ]'
      # footprint dynamic
      footprint: '[ [0.54, 0.38], [-0.54, 0.38], [-0.54, -0.38], [0.54, -0.38] ]'
      # footprint basic
      #footprint: '[ [0.6, 0.5], [-0.6, 0.5], [-0.6, -0.5], [0.6, -0.5] ]'
      footprint_padding: 0.01
      plugins: [“obstacle_layer”,  “voxel_layer”, “range_sensor_layer”, “denoise_layer”, “inflation_layer”] # Order matters!
      # For 2D obstacle representation using laser scan
      obstacle_layer:
        plugin: "nav2_costmap_2d::ObstacleLayer"
        enabled: True
        observation_sources: sick300laser
        sick300laser:
          topic: /mir_scan
          clearing: True
          marking: True
          data_type: "LaserScan"
          #raytrace_max_range: 3.0
          raytrace_min_range: 0.0
          obstacle_max_range: 2.5
          obstacle_min_range: 0.0
      # For 3D obstacle representation using depth camera
      voxel_layer:
        plugin: "nav2_costmap_2d::VoxelLayer"
        enabled: True
        max_obstacle_height: 3.0
        z_voxels: 10 # default
        origin_z: 0.0 # the origin of the voxel layer is set to the ground level
        z_resolution: 0.2 # default
        observation_sources: realsensed345
        realsensed345:
          topic: /camera_floor/obstacles
          clearing: True # False?
          marking: True
          data_type: "PointCloud2"
          raytrace_min_range: 0.0
          raytrace_max_range: 2.5 # 1.25?
          obstacle_min_range: 0.0
          obstacle_max_range: 2.5 # 1.25?
          min_obstacle_height: 0.0
          max_obstacle_height: 3.0
      ## “range_sensor_layer” ## for handling range sensor dara from ultrasonic sensor
      range_sensor_layer:
        enabled: False
      ## “denoise_layer” ## for removing salt and pepper noise from the sensors
      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 3.0
        inflation_radius: 0.55
      
      always_send_full_costmap: True

global_costmap:
  global_costmap:
    ros__parameters:
      transform_tolerance: 0.5 # 0.2
      update_frequency: 1.0
      publish_frequency: 1.0
      global_frame: map
      robot_base_frame: base_link
      use_sim_time: False
      # offset: front / back from base_link
      # footprint: '[ [front, width/2], [back, width/2], [-back, -width/2], [front, -width/2] ]'
      # footprint dynamic
      footprint: '[ [0.54, 0.38], [-0.54, 0.38], [-0.54, -0.38], [0.54, -0.38] ]'
      # footprint basic
      #footprint: '[ [0.6, 0.5], [-0.6, 0.5], [-0.6, -0.5], [0.6, -0.5] ]'
      footprint_padding: 0.01
      resolution: 0.05
      track_unknown_space: true
      plugins: ["obstacle_layer", "static_layer", "inflation_layer"]
      obstacle_layer:
        plugin: "nav2_costmap_2d::ObstacleLayer"
        enabled: True
        observation_sources: sick300laser
        sick300laser:
          topic: /mir_scan
          clearing: True
          marking: True
          data_type: "LaserScan"
          #raytrace_max_range: 3.0
          raytrace_min_range: 0.0
          obstacle_max_range: 2.5
          obstacle_min_range: 0.0
      static_layer:
        plugin: "nav2_costmap_2d::StaticLayer"
        map_subscribe_transient_local: True
      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 3.0
        inflation_radius: 0.55
      always_send_full_costmap: True

map_server:
  ros__parameters:
    use_sim_time: False
    # Overridden in launch by the "map" launch configuration or provided default value.
    yaml_filename: ""

map_saver:
  ros__parameters:
    use_sim_time: False
    save_map_timeout: 5.0
    free_thresh_default: 0.25
    occupied_thresh_default: 0.65
    map_subscribe_transient_local: True

planner_server:
  ros__parameters:
    expected_planner_frequency: 20.0
    use_sim_time: False
    planner_plugins: ["GridBased"]
    GridBased:
      plugin: "nav2_navfn_planner/NavfnPlanner"
      tolerance: 0.5
      use_astar: false
      allow_unknown: true

smoother_server:
  ros__parameters:
    use_sim_time: False
    smoother_plugins: ["simple_smoother"]
    simple_smoother:
      plugin: "nav2_smoother::SimpleSmoother"
      tolerance: 1.0e-10
      max_its: 1000
      do_refinement: True

behavior_server:
  ros__parameters:
    costmap_topic: local_costmap/costmap_raw
    footprint_topic: local_costmap/published_footprint
    cycle_frequency: 10.0
    behavior_plugins: ["spin", "backup", "drive_on_heading", "assisted_teleop", "wait"]
    spin:
      plugin: "nav2_behaviors/Spin"
    backup:
      plugin: "nav2_behaviors/BackUp"
    drive_on_heading:
      plugin: "nav2_behaviors/DriveOnHeading"
    wait:
      plugin: "nav2_behaviors/Wait"
    assisted_teleop:
      plugin: "nav2_behaviors/AssistedTeleop"
    global_frame: odom
    robot_base_frame: base_link
    transform_tolerance: 0.1
    use_sim_time: False
    simulate_ahead_time: 2.0
    max_rotational_vel: 0.5
    min_rotational_vel: 0.4
    rotational_acc_lim: 3.2

robot_state_publisher:
  ros__parameters:
    use_sim_time: False

waypoint_follower:
  ros__parameters:
    use_sim_time: False
    loop_rate: 20
    stop_on_failure: false
    waypoint_task_executor_plugin: "wait_at_waypoint"
    wait_at_waypoint:
      plugin: "nav2_waypoint_follower::WaitAtWaypoint"
      enabled: True
      waypoint_pause_duration: 200

velocity_smoother:
  ros__parameters:
    use_sim_time: False
    smoothing_frequency: 20.0
    scale_velocities: False
    feedback: "OPEN_LOOP"
    max_velocity: [0.26, 0.0, 1.0]
    min_velocity: [-0.26, 0.0, -1.0]
    max_accel: [2.5, 0.0, 3.2]
    max_decel: [-2.5, 0.0, -3.2]
    odom_topic: "odom"
    odom_duration: 0.1
    deadband_velocity: [0.0, 0.0, 0.0]
    velocity_timeout: 1.0
